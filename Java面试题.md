## **Java面试题**

[TOC]

### **第一章 相关概念**

------

#### **面向对象的三个特征**

封装，继承，多态，（抽象）

#### **多态的好处**

允许不同类对象对同一消息做出响应，即同一消息可以根据发送对象的不同而采用多种不同的行为方式(发送消息就是函数调用)。主要有以下优点：

- 可替换性：多态对已存在代码具有可替换性
- 可扩充性：增加新的子类不影响已经存在的类结构
- 接口性：多态是超类通过方法签名,向子类提供一个公共接口,由子类来完善或者重写它来实现的。
- 灵活性
- 简化性

#### **代码中如何实现多态**

1. 接口实现
2. 继承父类重写方法
3. 同一类中进行方法重载

#### **虚拟机是如何实现多态的**

动态绑定技术(dynamic binding)，执行期间判断所引用对象的实际类型，根据实际类型调用对应的方法。

#### **接口的意义**

规范，扩展，回调

#### **抽象类的意义**

- 为其他子类提供一个公共的类型
- 封装子类中重复定义的内容
- 定义抽象方法,子类虽然有不同的实现，但是定义时一致的

#### **接口和抽象类的区别**

| **比较**     | **抽象类**                                                   | **接口**                                                   |
| :----------- | :----------------------------------------------------------- | ---------------------------------------------------------- |
| 默认方法     | 抽象类可以有默认的方法实现                                   | java 8之前,接口中不存在方法的实现.                         |
| 实现方式     | 子类使用extends关键字来继承抽象类.如果子类不是抽象类,子类需要提供抽象类中所声明方法的实现. | 子类使用implements来实现接口,需要提供接口中所有声明的实现. |
| 构造器       | 抽象类中可以有构造器,                                        | 接口中不能                                                 |
| 和正常类区别 | 抽象类不能被实例化                                           | 接口则是完全不同的类型                                     |
| 访问修饰符   | 抽象方法可以有public,protected和default等修饰                | 接口默认是public,不能使用其他修饰符                        |
| 多继承       | 一个子类只能存在一个父类                                     | 一个子类可以存在多个接口                                   |
| 添加新方法   | 想抽象类中添加新方法,可以提供默认的实现,因此可以不修改子类现有的代码 | 如果往接口中添加新方法,则子类中需要实现该方法.             |

#### **静态变量和实例变量的区别?**

静态变量存储在方法区，属于类所有

实例变量存储在堆当中，其引用存在当前线程栈

#### **java 创建对象的几种方式**

- 采用new
- 通过反射
- 采用clone
- 通过序列化机制

#### **switch中能否使用string做参数**

在idk 1.7之前，switch只能支持byte, short, char, int或者其对应的封装类以及Enum类型

从idk 1.7之后switch开始支持String

#### **String s1=”ab”, String s2=”a”+”b”, String s3=”a”, String s4=”b”, s5=s3+s4请问s5==s2返回什么？**

在编译过程中，编译器会将s2直接优化为”ab”，会将其放置在常量池

s5则是被创建在堆区，相当于s5=new String(“ab”);

```java
public class test {
    public static void main(String[] args) {
        String s1 = "ab";
        String s2 = "a" + "b";
        String s3 = "a";
        String s4 = "b";
        String s5 = s3 + s4;
        String s6 = new String("ab");
        String s7 = new String("ab");

        System.out.println(s1 == s2);//true
        System.out.println(s1 == s5);//false

        System.out.println(s1 == s6);//false
        System.out.println(s6 == s7);//false
    }
}
```

#### **你对String对象的intern()熟悉么?**

intern()方法会首先从常量池中查找是否存在该常量值，如果常量池中不存在则现在常量池中创建，如果已经存在则直接返回。

```java
public class test {
    public static void main(String[] args) {
        String s1 = new String("ab");
        String s2 = s1.intern();
        System.out.println(s1 == s2);//false

        String s3 = "ab";
        String s4 = s3.intern();
        System.out.println(s3 == s4);//true
    }
}
```

#### **Object中有哪些公共方法?**

- equals()
- toString()
- clone()
- getClass()
- notify()，notifyAll()，wait()
- hashCode()


#### **为什么要有不同的引用类型**

Java不像C语言可以控制内存的申请和释放，在**Java中有时候我们需要适当的控制对象被回收的时机**，因此就诞生了不同的引用类型。有以下几个使用场景可以充分的说明：

- 利用软引用和弱引用解决OOM问题：用一个HashMap来保存图片的路径和相应图片对象关联的软引用之间的映射关系，在内存不足时JVM会自动回收这些缓存图片对象所占用的空间，从而有效地避免了OOM的问题.

  >  OOM，全称“Out Of Memory”，翻译成中文就是“内存用完了”，来源于java.lang.OutOfMemoryError

- 通过软引用实现Java对象的高速缓存:比如我们创建了一Person的类，如果每次需要查询一个人的信息,哪怕是几秒中之前刚刚查询过的，都要重新构建一个实例，这将引起大量Person对象的消耗，并且由于这些对象的生命周期相对较短，会引起多次GC影响性能。此时可以通过软引用和 HashMap 的结合可以构建高速缓存提高性能。

#### **java当中的四种引用**

强引用，软引用，弱引用，虚引用。不同的引用类型主要体现在GC上:

- 强引用：如果一个对象具有强引用，它就不会被垃圾回收器回收。即使当前内存空间不足，JVM也不会回收它，而是抛出 OutOfMemoryError 错误，使程序异常终止。如果想中断强引用和某个对象之间的关联，可以显式地将引用赋值为null，这样一来的话，JVM在合适的时间就会回收该对象。
- 软引用：在使用软引用时，如果内存的空间足够，软引用就能继续被使用，而不会被垃圾回收器回收，只有在内存不足时，软引用才会被垃圾回收器回收。
- 弱引用：具有弱引用的对象拥有的生命周期更短暂。因为当 JVM 进行垃圾回收，一旦发现弱引用对象，无论当前内存空间是否充足，都会将弱引用回收。不过由于垃圾回收器是一个优先级较低的线程，所以并不一定能迅速发现弱引用对象。
- 虚引用：相当于形同虚设，如果一个对象仅持有虚引用，那么它相当于没有引用，在任何时候都可能被垃圾回收器回收。

#### **equals()和hashcode()的联系**

hashCode()是Object类的一个方法，返回一个哈希值。如果两个对象根据equal()方法比较相等，那么两个对象中的hashCode()方法必须产生相同的哈希值。

如果两个对象根据eqaul()方法比较不相等，那么产生的哈希值不一定相等(碰撞的情况下还是会相等的。)

#### **a.hashCode()有什么用?与a.equals(b)有什么关系**

hashCode() 方法是相应对象整型的 hash 值。它常用于基于 hash 的集合类，如 Hashtable、HashMap、LinkedHashMap等等。它与 equals() 方法关系特别紧密。根据 Java 规范，使用 equal() 方法来判断两个相等的对象，必须具有相同的 hashcode。

将对象放入到集合中时，首先判断要放入对象的hashcode是否已经在集合中存在，不存在则直接放入集合。如果hashcode相等，然后通过equal()方法判断要放入对象与集合中的任意对象是否相等：如果equal()判断不相等，直接将该元素放入集合中，否则不放入。

#### **a==b与a.equals(b)有什么区别**

如果a 和b 都是对象，则 a==b 是比较两个对象的引用，只有当 a 和 b 指向的是堆中的同一个对象才会返回 true，而 a.equals(b) 是进行逻辑比较，所以通常需要重写该方法来提供逻辑一致性的比较。例如，String 类重写 equals() 方法，所以可以用于两个不同对象，但是包含的字母相同的比较。

#### **3 * 0.1== 0.3返回值是什么**

false，因为有些浮点数不能完全精确的表示出来

#### **a=a+b与a+=b有什么区别吗?**

+=操作符会进行隐式自动类型转换，此处a+=b隐式的将加操作的结果类型强制转换为持有结果的类型，而a=a+b则不会自动进行类型转换。

```
byte a;
byte b;
b = a + b; // error : cannot convert from int to byte
b += a; // ok
```

#### **& 和 &&的区别**

&是位操作，而&&是逻辑运算符。另外需要记住逻辑运算符具有短路特性，而&不具备短路特性。

```java
public class Test{
	static String name;
    
	public static void main(String[] args){
	if(name != null & name.equals("")){
		System.out.println("ok");
	}else{
		System.out.println("error");
 		}
 	}
 }
//抛出空指针异常
null是没有地址
""是有地址但是里面的内容是空的
```

> 指针只存在于c语言中，Java中是没有指针的，空指针就是空引用，java空指针异常就是引用本身为空，却调用了方法，这个时候就会出现空指针异常。可以理解成员变量和方法是属于对象的（除去静态），在对象中才存在相对应的成员变量和方法，然后通过对象去调用这些成员变量和方法。对于空指针来说，它不指向任何对象，也就没有所谓的成员变量和方法，这个时候用它去调用某些属性和方法，当然会出现空指针异常。

#### **一个java文件内部可以有类？**(非内部类)

只能有一个public公共类，但是可以有多个default修饰的类

#### **final, finalize和finally的不同之处**

final 是一个修饰符，可以修饰变量、方法和类

-  final 修饰变量，意味着该变量的值在初始化后不能被改变
- final修饰一个类时，表明这个类不能被继承
- 被final修饰的方法不能被重写

finalize 方法是在对象被回收之前调用的方法，给对象自己最后一个复活的机会，但是什么时候调用 finalize 没有保证

finally 是一个关键字，与 try 和 catch 一起用于异常的处理。finally 块一定会被执行，无论在 try 块中是否有发生异常。

#### **final有哪些用法**

1.被final修饰的类不可以被继承
2.被final修饰的方法不可以被重写
3.被final修饰的变量不可以被改变。如果修饰引用，那么表示引用不可变，引用指向的内容可变。
4.被final修饰的方法，JVM会尝试将其内联，以提高运行效率
5.被final修饰的常量，在编译阶段会存入常量池中。

#### **clone()是哪个类的方法?**

java.lang.Cloneable 是一个标示性接口，不包含任何方法，clone 方法在 object 类中定义。并且需要知道 clone() 方法是一个本地方法，这意味着它是由 c 或 c++ 或 其他本地语言实现的。

> Java中的方法分为两种：Java方法和本地方法。
>
> Java方法由Java语言编写，编译成字节码，存储在.class文件中。
>
> 本地方法由其他语言编写，编译成与处理器相关的机器代码，本地方法保存在动态链接库（如ddl中）。
>
> 本地方法的存在的意义，主要在于Java应用需要与JVM进行交互，当Java需要与操作系统或者某些硬件交换信息时，就需要用到本地方法。使用JNI能让Java与本地语言交互，但也意味着丧失了跨平台性。

#### **深拷贝和浅拷贝的区别是什么?**

浅拷贝：被复制对象的所有变量都含有与原来的对象相同的值，而所有的对其他对象的引用仍然指向原来的对象。

深拷贝：被复制对象的所有变量都含有与原来的对象相同的值，而那些引用其他对象的变量将指向被复制过的新对象，而不再是原有的那些被引用的对象。

> https://www.jianshu.com/p/94dbef2de298

#### **static都有哪些用法?**

几乎所有的人都知道static关键字这两个基本的用法：静态变量和静态方法。也就是被static所修饰的变量/方法都属于类的静态资源，类实例所共享。

除了静态变量和静态方法之外，static也用于静态块，多用于初始化操作：

此外static也多用于修饰内部类，此时称之为静态内部类。

最后一种用法就是静态导包，即 **import static.import static** 是在JDK 1.5之后引入的新特性，可以用来指定导入某个类中的静态资源，并且不需要使用类名.资源名，可以直接使用资源名，比如：

```java
import static java.lang.Math.*;
public class Test{ 
	public static void main(String[] args){
	//System.out.println(Math.sin(20));
	System.out.println(sin(20));
	}
}
```

#### **String, StringBuffer和StringBuilder区别**

- String是字符串常量，final修饰;
- StringBuffer字符串变量(线程安全)；
- StringBuilder 字符串变量(线程不安全)。

1. ##### String和StringBuffer

   String和StringBuffer主要区别是性能：String是不可变对象，每次对String类型进行操作都等同于产生了一个新的String对象，然后指向新的String对象。所以尽量不在对String进行大量的拼接操作，否则会产生很多临时对象，导致GC开始工作，影响系统性能。

   StringBuffer是对对象本身操作，而不是产生新的对象，因此在有大量拼接的情况下，我们建议使用StringBuffer。

   > 但是需要注意现在JVM会对String拼接做一定的优化：
   >
   > String s=“This is only ”+”simple”+”test”会被虚拟机直接优化成String s=“This is only simple test”，此时就不存在拼接过程。

2. ##### StringBuffer和StringBuilder

   StringBuffer是线程安全的可变字符串，其内部实现是可变数组。

   StringBuilder是jdk 1.5新增的，其功能和StringBuffer类似，但是非线程安全。

   **因此，在没有多线程问题的前提下，使用StringBuilder会取得更好的性能**

   

### **第二章 GC垃圾回收**

------

#### **简单的解释一下垃圾回收**

Java 垃圾回收机制最基本的做法是分代回收。内存中的区域被划分成不同的世代，对象根据其存活的时间被保存在对应世代的区域中。一般的实现是划分成3个世代：年轻、年老和永久。内存的分配是发生在年轻世代中的。当一个对象存活时间足够长的时候，它就会被复制到年老世代中。对于不同的世代可以使用不同的垃圾回收算法。进行世代划分的出发点是对应用中对象存活时间进行研究之后得出的统计规律。一般来说，一个应用中的大部分对象的存活时间都很短。比如局部变量的存活时间就只在方法的执行过程中。基于这一点，对于年轻世代的垃圾回收算法就可以很有针对性。

#### **调用System.gc()会发生什么?**

通知GC开始工作，但是GC真正开始的时间不确定

#### **你知道哪些垃圾回收算法?**

1. 标记-清除算法

   标记-清除算法是第一种使用和比较完善的垃圾回收算法，算法分为两个过程：1、标记正所有需要回收的对象2、标记完成后清除被标记的对象。其标记的过程就是判断对象有效性，执行可达性分析的过程。

   缺点：
   1、每次进行垃圾回收时，会暂停当前用户程序的运行（类似让所有的同学站起来）
   2、垃圾回收器需要间隔性的检查，并且标记和清除的过程相对较慢。
   3、在标记清除之后可能会产生大量内存碎片，导致一旦需要为大对象分配空间时，由于找不到足够大的内存空间，而不得以引发另外一次GC过程。

   <img src="C:\Users\wang1\Desktop\mdSource\GC\标记-清除.png" style="zoom:67%;" />

2. 标记-复制算法

   标记——复制存储算法通过采用双区域交替使用这种方式解决了标记-清除算法中效率低下的问题。它将可可用内存划分为两个等量的区域（使用区和空闲区），每次只使用一块。当正在使用的区域需要进行垃圾回收时，存活的对象将被复制到另外一块区域。原先被使用的区域被重置，转为空闲区。

   缺点： 
   1、原有可用空间被缩小为1/2，空间利用率降低了。 
   2、过程中也会暂停当前应用的运行。

   <img src="C:\Users\wang1\Desktop\mdSource\GC\标记-清除.png" style="zoom:67%;" />

3. 标记-整理算法

   标记-复制算法在对象存活率较高的情况下就要进行较多的复制操作，更重要的是该算法浪费一般的内存空间，为了解决该问题，出现了标记——整理算法：其标记的过程和“标记-清除”算法一样，而整理的过程则是让所有存活的对象都想另外一端移动，然后直接清理掉端边界以外的内存。

   缺点： 
   1、暂停当前应用的运行，非实时性的回收。

   <img src="C:\Users\wang1\Desktop\mdSource\GC\标记-整理.png" style="zoom:67%;" />

4. 分代回收算法

5. 增量收集算法

> http://blog.csdn.net/dd864140130/article/details/50084471
>

#### **如何判断一个对象是否应该被回收**

这就是所谓的对象存活性判断，常用的方法有两种：

- 引用计数法
- 对象可达性分析

> 由于引用计数法存在互相引用导致无法进行GC的问题，所以目前JVM虚拟机多使用对象可达性分析算法



### **第三章 进程、线程**

------

#### **进程，线程，协程之间的区别**

进程是程序运行和资源分配的基本单位，一个程序至少有一个进程，一个进程至少有一个线程。进程在执行过程中拥有独立的内存单元，而多个线程共享内存资源，减少cpu切换次数，从而效率更高。

线程是进程的一个实体，是cpu调度和分派的基本单位，是比程序更小的能独立运行的基本单位。同一进程中的多个线程之间可以并发执行。

#### **你了解守护线程吗？**它和非守护线程有什么区别

程序运行完毕，jvm会等待非守护线程完成后关闭，

但是jvm不会等待守护线程。守护线程最典型的例子就是GC线程。

#### **什么是多线程上下文切换**

多线程的上下文切换是指CPU控制权由一个已经正在运行的线程切换到另外一个就绪并等待获取CPU执行权的线程的过程。

#### **创建两种线程的方式?他们有什么区别?**

通过实现java.lang.Runnable或者通过扩展java.lang.Thread类。相比扩展Thread，实现Runnable接口可能更优：

- Java不支持多继承。因此扩展Thread类就代表这个子类不能扩展其他类。而实现Runnable接口的类还可能扩展另一个类。
- 类可能只要求可执行即可，因此继承整个Thread类的开销过大。

#### **Thread类中的start()和run()方法有什么区别?**

start()方法被用来启动新创建的线程，而且start()内部调用了run()方法，这和直接调用run()方法的效果不一样。当你调用run()方法的时候，只会是在原来的线程中调用，没有新的线程启动，start()方法才会启动新线程。

#### **怎么检测一个线程是否持有对象监视器**

Thread类提供了一个holdsLock(Object obj)方法，当且仅当对象obj的监视器被某条线程持有的时候才会返回true，注意这是一个static方法，这意味着”某条线程”指的是当前线程。

#### **Runnable和Callable的区别**

Runnable接口中的run()方法的返回值是void，它做的事情只是纯粹地去执行run()方法中的代码而已；Callable接口中的call()方法是有返回值的，是一个泛型，和Future、FutureTask配合可以用来获取异步执行的结果。

这其实是很有用的一个特性，因为多线程相比单线程更难、更复杂的一个重要原因就是因为多线程充满着未知性，某条线程是否执行了？某条线程执行了多久？某条线程执行的时候我们期望的数据是否已经赋值完毕？无法得知，我们能做的只是等待这条多线程的任务执行完毕而已。而Callable+Future/FutureTask却可以方便获取多线程运行的结果，可以在等待时间太长没获取到需要的数据的情况下取消该线程的任务。

#### **什么导致线程阻塞**

阻塞指的是暂停一个线程的执行以等待某个条件发生（如某资源就绪）

| **方法**              | **说明**                                                     |
| --------------------- | ------------------------------------------------------------ |
| sleep()               | sleep() 允许 指定以毫秒为单位的一段时间作为参数，它使得线程在指定的时间内进入阻塞状态，不能得到CPU 时间，指定的时间一过，线程重新进入可执行状态。典型地，sleep() 被用在等待某个资源就绪的情形：测试发现条件不满足后，让线程阻塞一段时间后重新测试，直到条件满足为止 |
| suspend() 和 resume() | 两个方法配套使用，suspend()使得线程进入阻塞状态，并且不会自动恢复，必须其对应的resume() 被调用，才能使得线程重新进入可执行状态。典型地，suspend() 和 resume() 被用在等待另一个线程产生的结果的情形：测试发现结果还没有产生后，让线程阻塞，另一个线程产生了结果后，调用 resume() 使其恢复。 |
| yield()               | yield() 使当前线程放弃当前已经分得的CPU 时间，但不使当前线程阻塞，即线程仍处于可执行状态，随时可能再次分得 CPU 时间。yield()方法只能使同优先级的线程有执行的机会。.调用 yield() 的效果等价于调度程序认为该线程已执行了足够的时间从而转到另一个线程 |
| wait() 和 notify()    | 两个方法配套使用，wait() 使得线程进入阻塞状态，它有两种形式，一种允许 指定以毫秒为单位的一段时间作为参数，另一种没有参数，前者当对应的 notify() 被调用或者超出指定时间时线程重新进入可执行状态，后者则必须对应的 notify() 被调用。 |
| join()                | 线程加入,是当前线程A调用另一个线程B的join()方法，当前线程转A入阻塞状态，直到线程B运行结束，线程A才由阻塞状态转为可执行状态。 |

#### **stop和suspend方法作用**

1. stop和suspend方法作用

   它们是Thread类的方法

   stop：用来终止一个线程

   suspend：用来阻塞一个线程直至另一个线程调用resume

2. stop天生就不安全，经验证明suspend经常导致死锁

   - stop弃用

     它终止未结束的方法（包括run方法），这会导致对象处于不一致状态。例：从一个账户向另一个账户转账的过程中被终止，钱已经转出，但没有输入目标账户。当线程要终止另一个线程时，无法知道什么时候调用stop是安全的，什么时候导致对象被破坏，因此，stop弃用

   - suspend弃用

     如果用suspend挂起一个持有锁的线程，挂起，锁仍占用。如果调用suspend方法的线程试图获得同一个锁，会有死锁。

#### **产生死锁的条件**

1.互斥条件：一个资源每次只能被一个进程使用。
2.请求与保持条件：一个进程因请求资源而阻塞时，对已获得的资源保持不释放。
3.不剥夺条件:进程已获得的资源，在末使用完之前，不能强行剥夺。
4.循环等待条件:若干进程之间形成一种头尾相接的循环等待资源关系。

#### **为什么wait()方法和notify()/notifyAll()方法要在同步块中被调用**

这是JDK强制的，wait()方法和notify()/notifyAll()方法在调用前都必须先获得对象的锁

#### **wait()方法和notify()/notifyAll()方法在放弃对象监视器时有什么区别**

wait()方法立即释放对象监视器，notify()/notifyAll()方法则会等待线程剩余代码执行完毕才会放弃对象监视器

> [经典解释监视器和对象锁](https://blog.csdn.net/fenglibing/article/details/1483930)

#### **wait()与sleep()的区别**

- sleep()来自Thread类，wait()来自Object类。调用sleep()方法的过程中，线程不会释放对象锁。而调用 wait ()让其他线程可以占用CPU。
- sleep(milliseconds)需要指定一个睡眠时间，时间一到会自动唤醒，而wait()需要配合notify()或者notifyAll()使用。

#### **为什么wait, nofity和nofityAll这些方法不放在Thread类当中**

一个很明显的原因是JAVA提供的锁是对象级的而不是线程级的，每个对象都有锁，通过线程获得。如果线程需要等待某些锁那么调用对象中的wait()方法就有意义了。如果wait()方法定义在Thread类中，线程正在等待的是哪个锁就不明显了。简单的说，由于wait，notify和notifyAll都是锁级别的操作，所以把他们定义在Object类中因为锁属于对象。

#### **java线程阻塞唤醒的四种方法**

- suspend和resume

  > Java废弃 suspend() 去挂起线程的原因，是因为 suspend() 
  > 在导致线程暂停的同时，并不会去释放任何锁资源。其他线程都无法访问被它占用的锁。直到对应的线程执行 resume() 
  > 方法后，被挂起的线程才能继续，从而其它被阻塞在这个锁的线程才可以继续执行。 

- wait和notify

  > wait与notify必须配合synchronized使用，因为调用之前必须持有锁，wait会立即释放锁，notify则是同步块执行完了才释放

- await和signal

  > Condition类提供，而Condition对象由
  >
  > new ReentLock().newCondition()获得，与wait和notify相同，因为使用Lock锁后无法使用wait方法

- park和unpark

  > LockSupport是一个非常方便实用的线程阻塞工具，它可以在线程任意位置让线程阻塞。和Thread.suspend(p)相比，它弥补了由于resume()在前发生，导致线程无法继续执行的情况。和Object.wait()相比，它不需要先获得某个对象的锁，也不会抛出IException异常。可以唤醒指定线程。

#### **synchronized和ReentrantLock的区别**

synchronized是关键字，ReentrantLock是类，这是二者的本质区别。既然ReentrantLock是类，那么它就提供了比synchronized更多更灵活的特性，可以被继承、可以有方法、可以有各种各样的类变量，ReentrantLock比synchronized的扩展性体现在几点上：

（1）ReentrantLock可以对获取锁的等待时间进行设置，这样就避免了死锁
（2）ReentrantLock可以获取各种锁的信息
（3）ReentrantLock可以灵活地实现多路通知

另外，二者的锁机制其实也是不一样的:ReentrantLock底层调用的是Unsafe的park方法加锁，synchronized操作的应该是对象头中mark word。

#### **FutureTask是什么**

FutureTask表示一个异步运算的任务。FutureTask里面可以传入一个Callable的具体实现类，可以对这个异步运算的任务的结果进行等待获取、判断是否已经完成、取消任务等操作。当然，由于FutureTask也是Runnable接口的实现类，所以FutureTask也可以放入线程池中。

#### **一个线程如果出现了运行时异常怎么办?**

如果这个异常没有被捕获的话，这个线程就停止执行了。

另外重要的一点是：如果这个线程持有某个某个对象的监视器，那么这个对象监视器会被立即释放。

#### **Java当中有哪几种锁**

- 自旋锁: 自旋锁在JDK1.6之后就默认开启了。基于之前的观察，共享数据的锁定状态只会持续很短的时间，为了这一小段时间而去挂起和恢复线程有点浪费，所以这里就做了一个处理，让后面请求锁的那个线程在稍等一会，但是不放弃处理器的执行时间，看看持有锁的线程能否快速释放。为了让线程等待，所以需要让线程执行一个忙循环也就是自旋操作。在jdk6之后，引入了自适应的自旋锁，也就是等待的时间不再固定了，而是由上一次在同一个锁上的自旋时间及锁的拥有者状态来决定。
- 偏向锁: 在JDK1.之后引入的一项锁优化，目的是消除数据在无竞争情况下的同步原语。进一步提升程序的运行性能。偏向锁就是偏心的偏，意思是这个锁会偏向第一个获得他的线程，如果接下来的执行过程中，改锁没有被其他线程获取，则持有偏向锁的线程将永远不需要再进行同步。偏向锁可以提高带有同步但无竞争的程序性能，也就是说他并不一定总是对程序运行有利，如果程序中大多数的锁都是被多个不同的线程访问，那偏向模式就是多余的，在具体问题具体分析的前提下，可以考虑是否使用偏向锁。
- 轻量级锁: 为了减少获得锁和释放锁所带来的性能消耗，引入了“偏向锁”和“轻量级锁”，所以在Java SE1.6里锁一共有四种状态，无锁状态，偏向锁状态，轻量级锁状态和重量级锁状态，它会随着竞争情况逐渐升级。锁可以升级但不能降级，意味着偏向锁升级成轻量级锁后不能降级成偏向锁。

#### **如何在两个线程间共享数据**

通过在线程之间共享对象就可以了，然后通过wait/notify/notifyAll、await/signal/signalAll进行唤起和等待，比方说阻塞队列BlockingQueue就是为线程之间共享数据而设计的。

#### **什么是线程局部变量ThreadLocal**

线程局部变量是局限于线程内部的变量，**属于线程自身所有**，不在多个线程间共享。Java提供ThreadLocal类来支持线程局部变量，是一种实现线程安全的方式。但是在管理环境下（如 web 服务器）使用线程局部变量的时候要特别小心，在这种情况下，工作线程的生命周期比任何应用变量的生命周期都要长。任何线程局部变量一旦在工作完成后没有释放，Java 应用就存在内存泄露的风险。

#### **ThreadLoal的作用是什么?**

简单说ThreadLocal就是一种以空间换时间的做法在每个Thread里面维护了一个ThreadLocal.ThreadLocalMap把数据进行隔离，数据不共享，自然就没有线程安全方面的问题了。

#### **生产者消费者模型的作用是什么?**

（1）通过平衡生产者的生产能力和消费者的消费能力来提升整个系统的运行效率，这是生产者消费者模型最重要的作用。
（2）解耦，这是生产者消费者模型附带的作用，解耦意味着生产者和消费者之间的联系少，联系越少越可以独自发展而不需要收到相互的制约。

#### **为什么要使用线程池**

避免频繁地创建和销毁线程，达到线程对象的重用。另外，使用线程池还可以根据项目灵活地控制并发的数目。

#### **java中用到的线程调度算法是什么**

抢占式。一个线程用完CPU之后，操作系统会根据线程优先级、线程饥饿情况等数据算出一个总的优先级并分配下一个时间片给某个线程执行。

#### **Thread.sleep(0)的作用是什么**

由于Java采用抢占式的线程调度算法，因此可能会出现某条线程常常获取到CPU控制权的情况，为了让某些优先级比较低的线程也能获取到CPU控制权，可以使用Thread.sleep(0)手动触发一次操作系统分配时间片的操作，这也是平衡CPU控制权的一种操作。

#### **什么是CAS**

CAS，全称为Compare and Swap，即比较-替换。假设有三个操作数：内存值V、旧的预期值A、要修改的值B，当且仅当预期值A和内存值V相同时，才会将内存值修改为B并返回true，否则什么都不做并返回false。当然CAS一定要volatile变量配合，这样才能保证每次拿到的变量是主内存中最新的那个值，否则旧的预期值A对某条线程来说，永远是一个不会变的值A，只要某次CAS操作失败，永远都不可能成功。

#### **什么是乐观锁和悲观锁**

乐观锁：乐观锁认为竞争不总是会发生，因此它不需要持有锁，将比较-替换这两个动作作为一个原子操作尝试去修改内存中的变量，如果失败则表示发生冲突，那么就应该有相应的重试逻辑。

悲观锁：悲观锁认为竞争总是会发生，因此每次对某资源进行操作时，都会持有一个独占的锁，就像synchronized，不管三七二十一，直接上了锁就操作资源了。

#### **ConcurrentHashMap的并发度是什么?**

ConcurrentHashMap的并发度就是segment的大小，默认为16，这意味着最多同时可以有16条线程操作ConcurrentHashMap，这也是ConcurrentHashMap对Hashtable的最大优势，任何情况下，Hashtable能同时有两条线程获取Hashtable中的数据

#### **ConcurrentHashMap的工作原理**

##### **jdk 1.6:**

ConcurrentHashMap是线程安全的，但是与Hashtable相比，实现线程安全的方式不同。Hashtable是通过对hash表结构进行锁定，是阻塞式的，当一个线程占有这个锁时，其他线程必须阻塞等待其释放锁。ConcurrentHashMap是采用分离锁的方式，它并没有对整个hash表进行锁定，而是局部锁定，也就是说当一个线程占有这个局部锁时，不影响其他线程对hash表其他地方的访问。
具体实现:ConcurrentHashMap内部有一个Segment.

##### **jdk 1.8**

在jdk 8中，ConcurrentHashMap不再使用Segment分离锁，而是采用一种乐观锁CAS算法来实现同步问题，但其底层还是“数组+链表->红黑树”的实现。

#### **CyclicBarrier和CountDownLatch区别**

这两个类非常类似，都在java.util.concurrent下，都可以用来表示代码运行到某个点上，二者的区别在于：

- CyclicBarrier的某个线程运行到某个点上之后，该线程即停止运行，直到所有的线程都到达了这个点，所有线程才重新运行；CountDownLatch则不是，某线程运行到某个点上之后，只是给某个数值-1而已，该线程继续运行。
- CyclicBarrier只能唤起一个任务，CountDownLatch可以唤起多个任务
- CyclicBarrier可重用，CountDownLatch不可重用，计数值为0该CountDownLatch就不可再用了。

#### **java中的++操作符线程安全么?**

不是线程安全的操作。它涉及到多个指令，如读取变量值，增加，然后存储回内存，这个过程可能会出现多个线程交差。

#### **你有哪些多线程开发良好的实践?**

- 给线程命名

- 最小化同步范围

- 优先使用volatile

- 尽可能使用更高层次的并发工具而非wait和notify()来实现线程通信,如BlockingQueue,Semeaphore

- 优先使用并发容器而非同步容器.

- 考虑使用线程池

  

### **第四章 volatile关键字**

------

#### **volatile能使得一个非原子操作变成原子操作吗?**

一个典型的例子是在类中有一个 long 类型的成员变量。如果你知道该成员变量会被多个线程访问，如计数器、价格等，你最好是将其设置为 volatile。为什么？因为 Java 中读取 long 类型变量不是原子的，需要分成两步，如果一个线程正在修改该 long 变量的值，另一个线程可能只能看到该值的一半（前 32 位）。但是对一个 volatile 型的 long 或 double 变量的读写是原子。

一种实践是用 volatile 修饰 long 和 double 变量，使其能按原子类型来读写。double 和 long 都是64位宽，因此对这两种类型的读是分为两部分的，第一次读取第一个 32 位，然后再读剩下的 32 位，这个过程不是原子的，但 Java 中 volatile 型的 long 或 double 变量的读写是原子的。volatile 修复符的另一个作用是提供内存屏障（memory barrier），例如在分布式框架中的应用。简单的说，就是当你写一个 volatile 变量之前，Java 内存模型会插入一个写屏障（write barrier），读一个 volatile 变量之前，会插入一个读屏障（read barrier）。意思就是说，在你写一个 volatile 域时，能保证任何线程都能看到你写的值，同时，在写之前，也能保证任何数值的更新对所有线程是可见的，因为内存屏障会将其他所有写的值更新到缓存。

#### **volatile类型变量提供什么保证?**

volatile 主要有两方面的作用:1.避免指令重排2.可见性保证.例如，JVM 或者 JIT为了获得更好的性能会对语句重排序，但是 volatile 类型变量即使在没有同步块的情况下赋值也不会与其他语句重排序。volatile 提供 happens-before 的保证，确保一个线程的修改能对其他线程是可见的。某些情况下，volatile 还能提供原子性，如读 64 位数据类型，像 long 和 double 都不是原子的(低32位和高32位)，但 volatile 类型的 double 和 long 就是原子的。



### **第五章 集合**

------

#### **Java中的集合及其继承关系**



#### **poll()方法和remove()方法区别？**

poll() 和 remove() 都是从队列中取出一个元素，但是 poll() 在获取元素失败的时候会返回空，但是 remove() 失败的时候会抛出异常。

#### **LinkedHashMap和PriorityQueue的区别**

PriorityQueue 是一个优先级队列,保证最高或者最低优先级的的元素总是在队列头部，但是 LinkedHashMap 维持的顺序是元素插入的顺序。当遍历一个 PriorityQueue 时，没有任何顺序保证，但是 LinkedHashMap 课保证遍历顺序是元素插入的顺序。

#### **WeakHashMap与HashMap的区别是什么?**

WeakHashMap 的工作与正常的 HashMap 类似，但是使用弱引用作为 key，意思就是当 key 对象没有任何引用时，key/value 将会被回收。

#### **ArrayList和LinkedList的区别?**

最明显的区别是 ArrrayList底层的数据结构是数组，支持随机访问，而 LinkedList 的底层数据结构是双向循环链表，不支持随机访问。使用下标访问一个元素，ArrayList 的时间复杂度是 O(1)，而 LinkedList 是 O(n)。

#### **ArrayList和Array有什么区别?**

- Array可以容纳基本类型和对象，而ArrayList只能容纳对象。
- Array是指定大小的，而ArrayList大小是固定的

#### **Comparator和Comparable的区别?**

Comparable 接口用于定义对象的自然顺序，而 comparator 通常用于定义用户定制的顺序。Comparable 总是只有一个，但是可以有多个 comparator 来定义对象的顺序。

#### **如何实现集合排序?**

你可以使用有序集合，如 TreeSet 或 TreeMap，你也可以使用有顺序的的集合，如 list，然后通过 Collections.sort() 来排序。

#### **如何打印数组内容**

你可以使用 Arrays.toString() 和 Arrays.deepToString() 方法来打印数组。由于数组没有实现 toString() 方法，所以如果将数组传递给 System.out.println() 方法，将无法打印出数组的内容，但是 Arrays.toString() 可以打印每个元素。

#### **LinkedList的是单向链表还是双向?**

双向循环列表，具体实现自行查阅源码。

#### **TreeMap是实现原理**

采用红黑树实现，具体实现自行查阅源码。



### **第六章 日期**

------

#### **SimpleDateFormat是线程安全的吗?**

非常不幸，DateFormat 的所有实现，包括 SimpleDateFormat 都不是线程安全的，因此你不应该在多线程序中使用，除非是在对外线程安全的环境中使用，如 将 SimpleDateFormat 限制在 ThreadLocal 中。如果你不这么做，在解析或者格式化日期的时候，可能会获取到一个不正确的结果。因此，从日期、时间处理的所有实践来说，我强力推荐 joda-time 库。

#### **如何格式化日期?**

Java 中，可以使用 SimpleDateFormat 类或者 joda-time 库来格式日期。DateFormat 类允许你使用多种流行的格式来格式化日期。



### **第七章 异常**

------

#### **throw和throws的区别**

throw用于主动抛出java.lang.Throwable 类的一个实例化对象，意思是说你可以通过关键字 throw 抛出一个 Error 或者 一个Exception，如：`throw new IllegalArgumentException(“size must be multiple of 2″)`,
而throws 的作用是作为方法声明和签名的一部分，方法被抛出相应的异常以便调用者能处理。Java 中，任何未处理的受检查异常强制在 throws 子句中声明。

### **第八章 序列化**

------

#### **Java 中，Serializable 与 Externalizable 的区别**

Serializable 接口是一个序列化 Java 类的接口，以便于它们可以在网络上传输或者可以将它们的状态保存在磁盘上，是 JVM 内嵌的默认序列化方式，成本高、脆弱而且不安全。Externalizable 允许你控制整个序列化过程，指定特定的二进制格式，增加安全机制。

### **第九章 JVM**

------

#### **平台无关性**

Java语言的一个非常重要的特点就是与平台的无关性。而使用Java虚拟机是实现这一特点的关键。一般的高级语言如果要在不同的平台上运行，至少需要编译成不同的目标代码。而引入Java语言虚拟机后，Java语言在不同平台上运行时不需要重新编译。Java语言使用模式Java虚拟机屏蔽了与具体平台相关的信息，使得Java语言编译程序只需生成在Java虚拟机上运行的目标代码（字节码），就可以在多种平台上不加修改地运行。Java虚拟机在执行字节码时，把字节码解释成具体平台上的机器指令执行。

#### **简单解释一下类加载器**

有关类加载器一般会问你四种类加载器的应用场景以及双亲委派模型,



更多的内容参看深入理解JVM加载器：

http://blog.csdn.net/dd864140130/article/details/49817357

#### **简述堆和栈的区别**

VM 中堆和栈属于不同的内存区域，使用目的也不同。栈常用于保存方法帧和局部变量，而对象总是在堆上分配。栈通常都比堆小，也不会在多个线程之间共享，而堆被整个 JVM 的所有线程共享。

#### **简述JVM内存分配**

- 基本数据类型比变量和对象的引用都是在栈分配的。
- 堆内存用来存放由new创建的对象和数组。
- 类变量（static修饰的变量），程序在一加载的时候就在堆中为类变量分配内存，堆中的内存地址存放在栈中。
- 实例变量：当你使用java关键字new的时候，系统在堆中开辟并不一定是连续的空间分配给变量，是根据零散的堆内存地址，通过哈希算法换算为一长串数字以表征这个变量在堆中的”物理位置”,实例变量的生命周期–当实例变量的引用丢失后，将被GC（垃圾回收器）列入可回收“名单”中，但并不是马上就释放堆中内存。
- 局部变量: 由声明在某方法，或某代码段里（比如for循环），执行到它的时候在栈中开辟内存，当局部变量一但脱离作用域，内存立即释放。